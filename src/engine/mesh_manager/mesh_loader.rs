
use super::mesh::{Mesh, MeshIndexed};

pub fn load_debug_cube() -> MeshIndexed {
    MeshIndexed { vertices: vec![
        // front
        -1.0, -1.0,  1.0, // 0
        1.0, -1.0,  1.0,  // 1
        1.0,  1.0,  1.0,  // 2
        -1.0,  1.0,  1.0, // 3
        // back
        -1.0, -1.0, -1.0, // 4
        -1.0,  1.0, -1.0, // 5
        1.0,  1.0, -1.0,  // 6
        1.0, -1.0, -1.0,  // 7
        // top
//        -1.0,  1.0, -1.0,  5
//        -1.0,  1.0,  1.0,  3
//        1.0,  1.0,  1.0,   2
//        1.0,  1.0, -1.0,   6
        // bottom
//        -1.0, -1.0, -1.0,  4
//        1.0, -1.0, -1.0,   7
//        1.0, -1.0,  1.0,   1
//        -1.0, -1.0,  1.0,  0
        // right
//        1.0, -1.0, -1.0,   7
//        1.0,  1.0, -1.0,   6
//        1.0,  1.0,  1.0,   2
//        1.0, -1.0,  1.0,   1
        // left
//        -1.0, -1.0, -1.0,  4
//        -1.0, -1.0,  1.0,  0
//        -1.0,  1.0,  1.0,  3
//        -1.0,  1.0, -1.0,  5
    ], colors: vec![
        // front
        0.583,  0.771,  0.014,  1.000,
        0.583,  0.771,  0.014,  1.000,
        // back
        0.609,  0.115,  0.436,  1.000,
        0.609,  0.115,  0.436,  1.000,
        // top
        0.327,  0.483,  0.844,  1.000,
        0.327,  0.483,  0.844,  1.000,
        // bottom
        0.822,  0.569,  0.201,  1.000,
        0.822,  0.569,  0.201,  1.000,
        // right
        0.535,  0.602,  0.923,  1.000,
        0.535,  0.602,  0.923,  1.000,
        // left
        0.310,  0.747,  0.185,  1.000,
        0.310,  0.747,  0.185,  1.000,
    ], indices: vec![
        0,  1,  2,      0,  2,  3,    // front
        4,  5,  6,      4,  6,  7,    // back
        5,  3,  2,      5,  2,  6,   // top
        4,  7,  1,      4,  1,  0,   // bottom
        7,  6,  2,      7,  2,  1,   // right
        4,  0,  3,      4,  3,  5,   // left
    ] }
}

pub fn load_debug_d20() -> MeshIndexed {
    let sqr5 = 5.0_f32.sqrt();
    let phi = (1.0 + sqr5) * 0.5;
    let golden_ratio = (10.0 + (2.0 * sqr5)).sqrt() / (4.0 * phi);
    let a = (1.0 / golden_ratio) * 0.5;
    let b = (1.0 / golden_ratio) / (2.0 * phi);
    MeshIndexed { vertices: vec![
        0.0,    b,   -a,
          b,    a,  0.0,
         -b,    a,  0.0,
        0.0,    b,    a,
        0.0,   -b,    a,
         -a,  0.0,    b,
        0.0,   -b,   -a,
          a,  0.0,   -b,
          a,  0.0,    b,
         -a,  0.0,   -b,
          b,   -a,  0.0,
         -b,   -a,  0.0,
    ], colors: vec![
        0.583,  0.771,  0.014,  1.000,
        0.609,  0.115,  0.436,  1.000,
        0.327,  0.483,  0.844,  1.000,
        0.822,  0.569,  0.201,  1.000,
        0.535,  0.602,  0.923,  1.000,
        0.310,  0.747,  0.185,  1.000,
        0.583,  0.771,  0.014,  1.000,
        0.609,  0.115,  0.436,  1.000,
        0.327,  0.483,  0.844,  1.000,
        0.822,  0.569,  0.201,  1.000,
        0.535,  0.602,  0.923,  1.000,
        0.310,  0.747,  0.185,  1.000,
        0.583,  0.771,  0.014,  1.000,
        0.609,  0.115,  0.436,  1.000,
        0.327,  0.483,  0.844,  1.000,
        0.822,  0.569,  0.201,  1.000,
        0.535,  0.602,  0.923,  1.000,
        0.310,  0.747,  0.185,  1.000,
        0.583,  0.771,  0.014,  1.000,
        0.609,  0.115,  0.436,  1.000,
    ], indices: vec![
         0,  1,  2,
         3,  2,  1,
         3,  4,  5,
         3,  8,  4,
         0,  6,  7,
         0,  9,  6,
         4, 10, 11,
         6, 11, 10,
         2,  5,  9,
        11,  9,  5,
         1,  7,  8,
        10,  8,  7,
         3,  5,  2,
         3,  1,  8,
         0,  2,  9,
         0,  7,  1,
         6,  9, 11,
         6, 10,  7,
         4, 11,  5,
         4,  8, 10,
    ] }
}